//////////////////////////////////////////////////////////////////////////////////=BEGIN CLOSED LICENSE//// Copyright(c) 2012 Andras Csizmadia.// http://www.vpmedia.eu//// For information about the licensing and copyright please // contact Andras Csizmadia at andras@vpmedia.eu.////=END CLOSED LICENSE////////////////////////////////////////////////////////////////////////////////package hu.vpmedia.entity;/**** Feel free to use this code however you wish.* Created by Joacim Magnusson (www.splashdust.net) */import flash.display.Sprite;import flash.events.Event;import flash.events.MouseEvent;import flash.events.KeyboardEvent;import flash.text.TextField;import flash.ui.Keyboard;import box2D.dynamics.B2Body;import box2D.dynamics.B2BodyDef;import box2D.dynamics.B2World;import box2D.dynamics.B2DebugDraw;import box2D.dynamics.joints.B2MouseJoint;import box2D.dynamics.joints.B2MouseJointDef;import box2D.collision.B2AABB;import box2D.collision.shapes.B2CircleDef;import box2D.collision.shapes.B2CircleShape;import box2D.collision.shapes.B2PolygonDef;import box2D.collision.shapes.B2PolygonShape;import box2D.collision.shapes.B2Shape;import box2D.collision.shapes.B2ShapeDef;import box2D.common.math.B2Vec2;import general.Input;import src.utils.PolygonTool;class Box2DMouseDraw{    static function main() : Void    {        #if !flash            neash.Lib.Init("Box2DMouseDraw",640,480);             neash.Lib.SetBackgroundColour(0x414647);        #end                new Box2DMouseDraw();                #if !flash            neash.Lib.Run();        #end    }        private var _b2World : B2World;    private var _iterations : Int;    private var _timeStep : Float;    private var _brush : Sprite;    private var _brushPoly : Array<Dynamic>;    private var _drawnPoly : Array<Dynamic>;    private var _drawnPolySprite : Sprite;    private var _centerPointSprite : Sprite;    private var _polyTool : PolygonTool;    private var _bodyCount : Int;    private var _bodyCountTf : TextField;    private var _drawTimer : haxe.Timer;    private var _b2dbgDraw : B2DebugDraw;    private var _shiftDown : Bool;    private var _input : Input;        public function new()     {        initB2();        setDebugDraw(flash.Lib.current);        _input = new Input(flash.Lib.current);                _bodyCount = 0;        _polyTool = new PolygonTool();        _bodyCountTf = new TextField();        flash.Lib.current.stage.addChild(_bodyCountTf);                // Set up run loop        flash.Lib.current.stage.addEventListener(Event.ENTER_FRAME, update);        flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);        flash.Lib.current.stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);        flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, keyListener);        flash.Lib.current.stage.addEventListener(KeyboardEvent.KEY_UP, keyListener);                // Make boundries        makeBody({x:320,y:480}, GetBoxVectors(640,20), true);        makeBody({x:0,y:240}, GetBoxVectors(20,480), true);        makeBody({x:640,y:240}, GetBoxVectors(20,480), true);    }        function mouseDownHandler(p_event:MouseEvent) : Void    {        if(GetBodyAtMouse(true) == null) {            // This is the visual drawing feedback sprite            _drawnPolySprite = new Sprite();            //_drawnPolySprite.x = flash.Lib.current.mouseX;            //_drawnPolySprite.y = flash.Lib.current.mouseY;            flash.Lib.current.addChild(_drawnPolySprite);            _centerPointSprite = new Sprite();            _drawnPolySprite.addChild(_centerPointSprite);                        // This is the polygon that will be used for making the box2D body            _drawnPoly = new Array();            _drawnPolySprite.graphics.lineStyle(2, 0xFFAAAA);            _centerPointSprite.graphics.lineStyle(2, 0xFFAAAA);            _drawnPolySprite.graphics.moveTo(_drawnPolySprite.mouseX, _drawnPolySprite.mouseY);            _drawnPoly.push({x:_drawnPolySprite.mouseX, y:_drawnPolySprite.mouseY});                        // Add a segment every 25 ms            flash.Lib.current.stage.addEventListener(Event.ENTER_FRAME, drawSequence);        }    }        function mouseUpHandler(p_event:MouseEvent) : Void    {        // Mouse button was released, remove the drawing feedback        _drawnPolySprite.graphics.clear();                // The body needs to be convex, so it will be converted before box2D gets it.        // _polyTool.getConvexPoly runs it through a Graham scan algorithm to find the convex hull.        // If _shiftDown is true, then the body will be static        if(_drawnPoly.length > 2)            makeBody({x:_drawnPolySprite.x,y:_drawnPolySprite.y}, _drawnPoly, _shiftDown);        flash.Lib.current.stage.removeEventListener(Event.ENTER_FRAME, drawSequence);        _drawnPoly = new Array();    }        function keyListener( event:KeyboardEvent ) : Void    {        if(event.type == "keyDown") {            if(event.keyCode == 84) { // T                _b2dbgDraw.m_drawFlags = B2DebugDraw.e_shapeBit|B2DebugDraw.e_jointBit|B2DebugDraw.e_coreShapeBit;            }            if(event.keyCode == 16) {                _shiftDown = true;            }        } else {            if(event.keyCode == 84) { // T                _b2dbgDraw.m_drawFlags = B2DebugDraw.e_shapeBit;            }                        if(event.keyCode == 16) {                _shiftDown = false;            }        }    }        function drawSequence(?e:Event) : Void    {        // Only draw segments that are at least 15 px long        if(_polyTool.lengthOfLine(_drawnPoly[_drawnPoly.length-1], {x:_drawnPolySprite.mouseX, y:_drawnPolySprite.mouseY}) > 15) {            // Do some tests to see if we are drawing horizontal or vertical lines            if(Math.floor(_drawnPoly[_drawnPoly.length-1].y/5) == Math.floor(_drawnPolySprite.mouseY/5)) {                _drawnPolySprite.graphics.lineTo(_drawnPolySprite.mouseX, _drawnPolySprite.mouseY);            } else if(Math.round(_drawnPoly[_drawnPoly.length-1].x/5) == Math.round(_drawnPolySprite.mouseX/5)) {                _drawnPolySprite.graphics.lineTo(_drawnPolySprite.mouseX, _drawnPolySprite.mouseY);            } else {                _drawnPolySprite.graphics.lineTo(_drawnPolySprite.mouseX, _drawnPolySprite.mouseY);                _drawnPoly.push({x:_drawnPolySprite.mouseX, y:_drawnPolySprite.mouseY});            }                        //var centroid:Dynamic = _polyTool.getCentroid(_drawnPoly);            //_centerPointSprite.graphics.clear();            //_centerPointSprite.graphics.lineStyle(2, 0xFFAAAA);            //_centerPointSprite.graphics.drawCircle(centroid.x, centroid.y, 10);            //_drawnPolySprite.graphics.moveTo(_drawnPolySprite.mouseX, _drawnPolySprite.mouseY);        }    }        function update(?p_event:Dynamic) : Void    {        Input.update();                // Update mouse joint        UpdateMouseWorld();        MouseDestroy();        MouseDrag();                _b2World.Step(_timeStep, _iterations);                _bodyCountTf.text = Std.string(_bodyCount);    }        function initB2() : Void    {        var worldAABB:B2AABB = new B2AABB();        worldAABB.lowerBound.Set(-10000.0, -10000.0);        worldAABB.upperBound.Set(10000.0, 10000.0);        var gravity:B2Vec2 = new B2Vec2(0.0, 15.0);        var doSleep:Bool = true;                _iterations = 10;        _timeStep = 1.0/30.0;                // Construct a world object        _b2World = new B2World(worldAABB, gravity, doSleep);            }        function setDebugDraw(sprite:Sprite) : Void    {        _b2dbgDraw = new B2DebugDraw();        var dbgSprite = new Sprite();        sprite.addChild(dbgSprite);        _b2dbgDraw.m_sprite = dbgSprite;        _b2dbgDraw.m_drawScale = 30.0;        _b2dbgDraw.m_fillAlpha = 0.4;        _b2dbgDraw.m_lineThickness = 1.0;        _b2dbgDraw.m_drawFlags = B2DebugDraw.e_shapeBit;        _b2World.SetDebugDraw(_b2dbgDraw);    }        function makeBody(p_pos:Dynamic, p_vertices:Array<Dynamic>, p_static = false) : Void    {        var body:B2Body;        var bodyDef:B2BodyDef;                bodyDef = new B2BodyDef();                body = _b2World.CreateBody(bodyDef);        body.SetXForm(new B2Vec2(p_pos.x/30.0, p_pos.y/30.0), 0);                // If there are more than 8 vertices, its a complex body        if(p_vertices.length > 8) {            makeComplexBody(body, p_vertices, p_static);        } else {            if(_polyTool.isPolyConvex(p_vertices) && _polyTool.isPolyClockwise(p_vertices)) {                makeSimpleBody(body, p_vertices, p_static);            } else {                makeComplexBody(body, p_vertices, p_static);            }        }    }            function makeSimpleBody(p_body:B2Body, p_vertices:Array<Dynamic>, p_static = false) : Void    {        var vertArray = p_vertices.slice(0);        vertArray.reverse();                var polyDef:B2PolygonDef;        polyDef = new B2PolygonDef();        polyDef.friction = 0.5;        polyDef.restitution = 0.7;                if(p_static)            polyDef.density = 0.0;        else            polyDef.density = 1.0;                polyDef.vertexCount = p_vertices.length;        var i:Int = 0;        for(vertex in vertArray) {            polyDef.vertices[i].Set(vertex.x/30,vertex.y/30);            i++;        }        p_body.CreateShape(polyDef);        p_body.SetMassFromShapes();        _bodyCount++;    }        function makeComplexBody(p_body:B2Body, p_vertices:Array<Dynamic>, p_static = false) : Void    {        var vertArray = p_vertices.slice(0);        if(!_polyTool.isPolyClockwise(vertArray))            vertArray.reverse();        var polys = _polyTool.earClip(vertArray);                if(polys != null) {                        for(poly in polys) {                if(poly != null) {                                        var polyDef:B2PolygonDef;                    polyDef = new B2PolygonDef();                    polyDef.friction = 0.5;                    polyDef.restitution = 0.7;                                        if(p_static)                        polyDef.density = 0.0;                    else                        polyDef.density = 1.0;                                        polyDef.vertexCount = poly.length;                                        var i:Int = 0;                    for (vertex in poly) {                        polyDef.vertices[i].Set(vertex.x/30, vertex.y/30);                        i++;                    }                                        p_body.CreateShape(polyDef);                }            }                        p_body.SetMassFromShapes();            _bodyCount++;                    } else {            makeComplexBody(p_body, _polyTool.getConvexPoly(p_vertices), p_static);        }    }        // The mouse related funtions are from the box2d test app    //        public var m_mouseJoint:B2MouseJoint;    // world mouse position    public var mouseXWorldPhys:Float;    public var mouseYWorldPhys:Float;    public var mouseXWorld:Float;    public var mouseYWorld:Float;        //======================    // Update mouseWorld    //======================    public function UpdateMouseWorld():Void{        mouseXWorldPhys = (Input.mouseX)/30.0;         mouseYWorldPhys = (Input.mouseY)/30.0;                 mouseXWorld = (Input.mouseX);         mouseYWorld = (Input.mouseY);     }        //======================    // Mouse Drag     //======================    public function MouseDrag():Void{        // mouse press                if (Input.mouseDown && m_mouseJoint == null){                                    var body:B2Body = GetBodyAtMouse();                        if (body != null)            {                                                var md:B2MouseJointDef = new B2MouseJointDef();                md.body1 = _b2World.GetGroundBody();                md.body2 = body;                md.target.Set(mouseXWorldPhys, mouseYWorldPhys);                md.maxForce = 300.0 * body.GetMass();                md.timeStep = _timeStep;                m_mouseJoint = cast(_b2World.CreateJoint(md),B2MouseJoint);                                body.WakeUp();                            }                    }                        // mouse release        if (!Input.mouseDown){            if (m_mouseJoint != null)            {                _b2World.DestroyJoint(m_mouseJoint);                m_mouseJoint = null;            }        }                                // mouse move        if (m_mouseJoint != null)        {            var p2:B2Vec2 = new B2Vec2(mouseXWorldPhys, mouseYWorldPhys);            m_mouseJoint.SetTarget(p2);        }            }                //======================    // Mouse Destroy    //======================    public function MouseDestroy():Void{        // mouse press        if (!Input.mouseDown && Input.isKeyPressed(68/*D*/)){                        var body:B2Body = GetBodyAtMouse(true);                        if (body != null)            {                _b2World.DestroyBody(body);                return;            }        }    }        //======================    // GetBodyAtMouse    //======================    private var mousePVec:B2Vec2;    public function GetBodyAtMouse(?includeStatic:Bool = false):B2Body{        // Make a small box.                mousePVec = new B2Vec2();        mousePVec.Set(mouseXWorldPhys, mouseYWorldPhys);        var aabb:B2AABB = new B2AABB();                aabb.lowerBound.Set(mouseXWorldPhys - 0.001, mouseYWorldPhys - 0.001);        aabb.upperBound.Set(mouseXWorldPhys + 0.001, mouseYWorldPhys + 0.001);                // Query the world for overlapping shapes.        var k_maxCount:Int = 10;        var shapes = new Array<Dynamic>();        var qCount:Int = _b2World.Query(aabb, shapes, k_maxCount);                var body:B2Body = null;                for (i in 0...qCount)        {            var s:B2Shape = cast shapes[i];                        if (s.GetBody().IsStatic() == false || includeStatic)            {                        var tShape:B2Shape = s;                var inside:Bool = tShape.TestPoint(tShape.GetBody().GetXForm(), mousePVec);                if (inside)                {                            body = tShape.GetBody();                    break;                }            }        }        return body;    }        function GetBoxVectors(w:Float, h:Float) : Array<Dynamic>    {        return [{x:-(w/2), y:-(h/2)}, {x:-(w/2), y:(h/2)}, {x:(w/2), y:(h/2)}, {x:(w/2), y:-(h/2)}];    }}